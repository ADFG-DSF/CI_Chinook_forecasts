---
title: "Kenai 2024"
author: "Nick DeCovich"
date: "2023-11-06"
output:
  html_document: default
  pdf_document: default
  word_document: default
---
```{r setup, include=FALSE, warning=FALSE}
#Note to Nick. TO me it makes sense to lump all of this together as it is all prep for the analysis which can use common options (Warning = FALSE being a big one.)
knitr::opts_chunk$set(echo = TRUE) #Use these defalts whaen you want to echo more than you don't.
knitr::opts_chunk$set(warning = FALSE) #Mostly the warnings can/should be left out of the output but I generally run it with them first (by commenting out this line)

devtools::install_github("adamreimer/preseason")
library(preseason)
library(tidyverse)

rm(list = ls())

#comp models function w mape added in.
comp_models2 <- function(dat, comp_age, years = 5){
  age <- paste0("age", comp_age)
  diff <- dat %>%
    dplyr::select(byr, !!age, dplyr::ends_with("pred")) %>%
    tidyr::gather(type, pred, -byr, -!!age) %>%
    dplyr::mutate(d = pred - (!!as.name(age)),
                  pe = d / (!!as.name(age)))
  
  plot <- ggplot2::ggplot(diff, ggplot2::aes(x = byr, y = pred, color = type)) +
    ggplot2::geom_jitter(width = 0.2, alpha = 0.5, size = 3) +
    ggplot2::geom_point(ggplot2::aes_string(y = age), color = "black") +
    ggplot2::geom_line(ggplot2::aes_string(y = age), color = "black")
  
  table <- diff %>%
    dplyr::group_by(type) %>%
    dplyr::top_n(years, byr) %>%
    dplyr::summarise(md = mean(d),
                     mad = mean(abs(d)),
                     mape = mean(abs(pe)))
  
  list(plot, table)
}

#Read in Kenai late brood table
brood <- read.csv(".\\KenaiLate2024.csv") #you can make the reference relative so your analysis is portable

#prep data for analysis
dat5 <- prep_brood(brood, 5:5)
dat6 <- prep_brood(brood, 5:6)
dat7 <- prep_brood(brood, 5:7)
```


## Age 5 models

```{r age 5 models}
#Note to Nick: I would say echo = TRUE on this chuck so that we can see what output relates to what call. Otherwise we have to comment out some stuff or break 
#into several code chunks and explain each one with text.

#Moving average model
## predictions
dat5$md5_pred <- pred_ma(dat5$ln, yrs = 5)[, "median"]

#univariate ARIMA
forecast::tsdisplay(dat5$ln, )
forecast::auto.arima(dat5$ln) # This is a random walk model (the most naive forecast out there)
ARIMA5_diff <- arima(dat5$ln, order=c(0,1,0))
summary(ARIMA5_diff)
## predictions
temp5U <- pred_arima(ARIMA5_diff, x = dat5$ln)
dat5$univariate_pred <- exp(temp5U[1,])

#exponential smoothing
ets5 <- forecast::ets(dat5$ln)
## predictions
dat5$es_pred <- pred_es(dat5$ln)

#compare models
comp_models2(dat5, 5, years = 5)
```

Here is an example where it really works better to break out the result. Notice that comp models picks the ARIMA difference model as the best predictor, which is equivalent to a random walk. There is nothing wrong with that even if it has low predictive ability (the prediction is last years value). But a close look at the model comparison plot above shows that exponential smoothing has done better the last several years but did poorly 4 and 5 years ago when the population dropped precipitously. We can verify that by looking at the MAD for the past 3 years... which would suggest exponential smoothing as a better model.

```{r age 5 3 year MAD}
#compare models
## Notice most of the difference comes from 4 and 5 years ago when the population was in serious decline.
##exponential smoothing better recently
comp_models2(dat5, 5, years = 3)
```

```{r age 5 predictions, echo=FALSE, include = FALSE}
#Note to Nick. Without contect I would not show these results at all.

#Moving average model
tail(dat5)
exp(mean(dat5$ln[29:33]))

#univariate ARIMA
forecast5_2024 <- exp(predict(ARIMA5_diff, n.ahead = 1)$pred)

#exponential smoothing
exp(predict(ets5, h = 1)[["mean"]][1])
```

## Age 6 models
```{r age 6 models}
#Moving average
## predictions
dat6$moving_avg_pred <- pred_ma(dat6$age6_ln, yrs = 5)[, "median"]

#univariate ARIMA
forecast::tsdisplay(dat6$age6_ln)
forecast::auto.arima(dat6$age6_ln) # Suggests a random walk
ARIMA6_diff <- arima(dat6$age6_ln, order=c(0,1,0))
ARIMA6_diff
forecast::tsdisplay(residuals(ARIMA6_diff)) #information free
#predictions
temp_ARIMA6 <- pred_arima(ARIMA6_diff, x = dat6$age6_ln) #more informative names
dat6$ARIMA_pred <- exp(temp_ARIMA6[1,])

#exponential smooting
ets6 <- forecast::ets(dat6$age6_ln)
#predictions
dat6$es_pred <- pred_es(dat6$age6_ln)

#sibling model
ggplot2::ggplot(dat6, ggplot2::aes(x = age5_ln, y = age6_ln)) + #this relationship looks pretty good. Shame not to use.
  ggplot2::geom_point()
sib6 <- lm(age6_ln ~ age5_ln, data = dat6)
summary(sib6) #model significant
par(mfrow = c(2,2)); plot(sib6); par(mfrow = c(1,1)) #residuals not terrible
forecast::tsdisplay(residuals(sib6)) #but appear to contain some additional information
forecast::auto.arima(sib6$model$age6_ln, xreg = sib6$model$age5_ln) #suggests we should difference the data first.
sib6_diff <- arima(sib6$model$age6_ln, order=c(0,1,0), xreg = sib6$model$age5_ln, method = "ML")
sib6_diff
AIC(sib6_diff, ARIMA6_diff)
forecast::tsdisplay(residuals(sib6_diff)) #better
## predictions
dat6$sibling_pred <- exp(pred_arima(sib6_diff, x = sib6$model$age6_ln, xreg = sib6$model$age5_ln)[1,])

#Ricker
plot(dat6$S, dat6$lnRS)
rick6 <- lm(lnRS ~ S, data = dat6)
summary(rick6) #Note the model in barely significant
par(mfrow = c(2,2)); plot(rick6); par(mfrow = c(1,1)) 
dat6[19, ] #Note high leverage residual is the largest value of S
forecast::tsdisplay(residuals(rick6)) #information left in the residuals
forecast::auto.arima(rick6$model$lnRS, xreg = rick6$model$S) #suggests we should difference the data first.
rick6_diff <- arima(rick6$model$lnRS, order=c(0,1,0), xreg = rick6$model$S, method = "ML")
AIC(rick6, rick6_diff)
rick6_diff
AIC(rick6_diff, ARIMA6_diff)
forecast::tsdisplay(residuals(rick6_diff)) #better
## predictions
dat6$ricker_pred <- exp(pred_arima(rick6_diff, x = rick6$model$lnRS, xreg = rick6$model$S)[1,]) * rick6$model$S

#compare models
comp_models2(dat6, 6)
```

```{r age 6 predictions, echo=FALSE, include = FALSE}
#moving average model
tail(dat6)
exp(mean(dat6$age6_ln[28:32]))

#univariate ARIMA
exp(predict(ARIMA6_diff, n.ahead = 1)$pred)

#ets
exp(predict(ets6, h = 1)[["mean"]][1])

#sibling
tail(brood, 10)
forecast6_2024 <- exp(predict(sib6_diff, 1, newxreg = log(5214))[[1]])

#ricker 
tail(brood, 10)
exp(predict(rick6_diff, 1, newxreg = 17405)[[1]]) * 17405
```
## Age 7 models

```{r age 7 models}
#Moving average
## predictions
dat7$moving_avg_pred <- pred_ma(dat7$age7_ln, yrs = 5)[, "median"]

#univariate ARIMA
forecast::tsdisplay(dat7$age7_ln)
forecast::auto.arima(dat7$age7_ln) # Random walk again
ARIMA7_diff <- arima(dat7$age7_ln, order=c(0,1,0))
summary(ARIMA7_diff)
tempU7 <- pred_arima(ARIMA7_diff, x = dat7$age7_ln)
## predictions
dat7$univariate_pred <- exp(tempU7[1,])

#exponential smoothing
ets7 <- forecast::ets(dat7$age7_ln)
## predictions
dat7$es_pred <- pred_es(dat7$age7_ln)

#sibling model
ggplot2::ggplot(dat7, ggplot2::aes(x = age6_ln, y = age7_ln)) + ggplot2::geom_point()
sib7 <- lm(age7_ln ~ age6_ln, data = dat7)
summary(sib7)
par(mfrow = c(2,2)); plot(sib7); par(mfrow = c(1,1))
forecast::tsdisplay(residuals(sib7))
## predictions
temp7 <- pred_lm(sib7)
dat7$sibling_pred <- exp(temp7[1,])

#Ricker
plot(dat7$S, dat7$lnRS)
rick7 <- lm(lnRS ~ S, data = dat7)
summary(rick7) #model insignificant
par(mfrow = c(2,2)); plot(rick7); par(mfrow = c(1,1))
forecast::tsdisplay(residuals(rick7)) # I  don't see a lot of information in these
## predictions
temp_Ricker7 <- exp(pred_lm(rick7)) * rick7$model$S
dat7$ricker_pred <- temp_Ricker7[1, ]

#compare models
comp_models2(dat7, 7)
```

## Age 7 predictions

```{r age 7 predictions, echo=FALSE, include = FALSE}
#moving average model
tail(dat7)
forecast7_2024 <- exp(mean(dat7$age7_ln[27:31]))

#ets
exp(predict(ets7, h = 1)[["mean"]][1])

#univariate ARIMA
exp(predict(ARIMA7_diff, n.ahead = 1)$pred)

#sibling
tail(brood,10)
pred_sib7 <- predict(sib7, newdata = data.frame(age6_ln = log(9322)), se.fit = TRUE)
exp(pred_sib7$fit)

#ricker 
tail(brood, 10)
exp(predict(rick7, newdata = data.frame(S = 20583))) * 20583
```

```{r PI calculations}
################################# Calculate prediction intervals ##################################################
############################## Carefull!!!!! modify this before you run it so you don't overwrite dat objects #######
#2024 forecast
forecast5_2024 #ARIMA
forecast6_2024 #Sibling
forecast7_2024 # Moving Average
forecast_2024 <- forecast5_2024[1] + forecast6_2024[1] + forecast7_2024

#Dataframe keypunched from Tony's memo.
#I think this methods is a touch better be it retains variability associated with the model selection process.
#admittedly the selection process has changed. but there is also no guarantee we would choose the same models in past years. 
#Historic age4-6 forecast and actual
dat <- 
  data.frame(
    forecast = c(33613, 21508, 21746, 22707, 18406, 16004, 13630),
    actual = c(30734, 18364, 13360, 12226, 12794, 14078, 14537)
  )

#forecasts bias high, worst at small run sizes
ggplot2::ggplot(dat, ggplot2::aes(x = actual, y = forecast)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggplot2::geom_abline(slope = 1)

dat$resid <- log(dat$forecast) - log(dat$actual)
#CI on log scale
#forecast includes age3 while errors fo not.
s <- sqrt(sum(dat$resid^2)/dim(dat)[1])
t <- qt(.90, df = dim(dat)[1] - 1)
exp(log(forecast_2024) + s * c(-t , t))



# #calculate return year and prep data
# dat5$ryr <- dat5$byr + 5
# dat6$ryr <- dat6$byr + 6
# dat7$ryr <- dat7$byr + 7
# 
# dat5CI <- dat5[dat5$ryr %in% 2019:2023, c("ryr", "age5", "univariate_pred")] #Note some of these might change if we use the work I did here.
# dat6CI <- dat6[dat6$ryr %in% 2019:2023, c("ryr", "age6", "sibling_pred")]
# dat7CI <- dat7[dat7$ryr %in% 2019:2023, c("ryr", "age7", "moving_avg_pred")]
# 
# #calculate errors
# errors <- 
#   dplyr::left_join(dat5CI, dat6CI, "ryr") %>%
#   dplyr::left_join(dat7CI,"ryr") %>%
#   dplyr::mutate(return = age5 + age6 + age7, #Note the data is posterior medians so they will not sum to the posterior median total.
#                 hind = univariate_pred  + sibling_pred + moving_avg_pred,
#                 error = log(hind) - log(return))
# 
# #rmse 80% bounds
# exp(log(forecast_2024) + sqrt(sum(errors$error^2)/dim(errors)[1]) * c(qt(.1, dim(errors)[1] - 1), qt(.9, dim(errors)[1] - 1)))

```

